---
layout: post
title: "自动升级程序"
categories:
- Software
tags: []
status: publish
type: post
published: true
meta:
  blogger_blog: missdeer.blogspot.com
  blogger_author: missdeerhttp://www.blogger.com/profile/18003139432457999590noreply@blogger.com
  blogger_permalink: "/2008/05/blog-post.html"
author:
  login: missdeer
  email: missdeerme@163.com
  display_name: missdeer
  first_name: "樊"
  last_name: "杨"
---
<p>　　今天一时兴起，修改了一会儿自动升级程序。这个自动升级程序半年前就做了，当时用的boost::asio来实现http下载文件，可是问题就在于下载时，CPU占用99%，而且下载速度并不快，这让我很郁闷，在网上也没有找到确实可行的解决方法。后来觉得功能基本可用了，就一直丢在那里不管了。<br />　　前些日子，另一个同事也开始为Impeller做了一个自动升级程序。那个程序的实现我不喜欢，它在升级时没有一个可见的需要升级的文件列表，进度条也只有一个总的，总之至少从界面上看，是个很土的程序。不过它除了能升级本地应用程序的必要文件外，还能进行Gems包的升级。另外，似乎它还可以在文件被替换的前后，执行一些额外的操作，比如一个COM组件可能需要注册，这时这个功能就很有价值了。不过，有时候我又觉得，有必要那么复杂吗，它还想内嵌一个Ruby解释器，能执行Ruby脚本，晕死！<br />　　在我心中，一个比较理想的升级程序应该是这样的：<br />1、每次都是从一个指定的地方获取一个文件列表，文件列表中记录了可升级的文件的相关信息，如文件名、相对路径、大小、hash值、日期、版本号等，每次都是将本地的文件跟文件列表中的信息进行比较，才得出是否需要升级的决定；<br />2、一般下载文件都是通过http的方式（比较简单）实现，这样可以实现多线程及断点续传；<br />3、下载时，有针对当前下载文件的进度以及所有文件的总进度；<br />4、允许用户中断升级过程；<br />5、能自动替换文件，包括被打开的文件；<br />6、能最小化到托盘图标；<br />7、能通过配置就可以直接适应其他升级需求（配置可以放在文件中、注册表中，或直接通过命令行得到）；<br />8、在替换文件前后，可以执行简单的命令行，不需要执行什么脚本程序那么复杂；<br />9、升级程序自身文件体积应该比较小；<br />10、有良好的出错保护机制；<br />11、可自动生成第一步需要的文件列表；<br />12、支持子目录中的文件升级。<br />　　暂时就只想到这些，呵呵，抽空用WTL写一个。</p>
