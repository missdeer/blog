---
layout: post
title: "终于借到《Lex与Yacc》了"
categories: []
tags: []
status: publish
type: post
published: true
meta:
  blogger_blog: missdeer.blogspot.com
  blogger_author: missdeerhttp://www.blogger.com/profile/18003139432457999590noreply@blogger.com
  blogger_permalink: "/2008/09/lexyacc.html"
author: 
---
<p>　　几个月前，就想从公司图书馆去借本《Lex与Yacc》了，可是从在线服务中可以查到确实有一本没有借出去，但到了图书馆就是找不到那本书放在什么地方了，图书馆的人说他们也没有办法找到，因为书要么就是照着编号放在书架上的，如果在指定的书架上没有，那就没办法了。我还为此去了几次图书馆，希望碰碰运气万一某一天他们整理的时候能发现那本没有找到的书，但是一次一次都失望而归。也想过自己买一本，但逛过深圳的几处大型书城，都没有找到过，从网上倒是能看到介绍，可是都是断货了，太郁闷了！<br />　　昨天觉得该去还那本《Windows技术内幕》了，虽然借了三个月，但没看几页。到图书馆一看，惊喜地发现有一本《Lex与Yacc》静静地躺在柜台面上，看来是刚刚有人还回来的，连忙抢到手中。<br />　　实在觉得这词法分析和语法分析在处理模式化文本时太有用了。说起来虽然现在在做那个劳什子一体化平台，可是我心里却一直想回去完善编辑器，简直有种生不逢时，壮志未酬的感觉。本来同事是有一种语法解析组件的，大概浏览过那代码，其实是从ruby源代码里抠出来，在某一阶段直接把语法分析树dump出来。不过不知道为什么在源代码超过8000行时，分析出来的行号总是过绕接，从头开始。我也没仔细定位过这个问题到底是哪里出了错，主要是那代码全是别人写的，而且用了一些我个人极不喜欢的处理方式，我就懒得再去查错和修正了。我宁可自己再写一个解析器，因为我知道用lex和yacc可以做到。当时简单地看过ruby的源代码，发现它的词法分析器并不是用lex生成的，并且里里有一段代码是用gperf生成的，于是以为gperf也是一种词法分析器生成器，后来自己用了gperf才明白过来，原来ruby的词法分析器是手写的，其中gperf生成的那段代码只是为了识别出其中的保留字而已。而语法分析器确实像是用yacc生成的，不过由于ruby的语法太过于魔幻，所以语法分析器似乎复杂得超出我的想像。如果我回头再去做编辑器，这个语法解析器势在必行，不关是为了解析出语法树显示出来，另外还有些用途。其中之一是，其中有一个另外的需求是将表格化的描述与脚本来回转换，如果没有可靠的语法解析器支持，这个需求要实现就实在太过困难了点。另外还有个需求，是前两天才提出来的，说是要能跳转到方法定义处，于是当然要知道方法定义的位置，而这位置当然需要事先准备好。本来还以为rdoc从源代码中提取文件时可以顺便提取出来，后来同事一说，yaml中并没有保留文件名和行号，所以还得想办法提出来。我一想这个就太不可靠了点，万一某些方法就是没有注释文档呢。所以一定要另外有个模块来提取方法定义，我当时想到了ctags。今天试了试，发现用ctags还是有些缺憾，它只能提取出方法名称，以及匹配该名称的正则表达式，而并没有行号。另外，看了看ctags的源代码，发现另外更严重的问题，ruby并没有说定义方法时def关键字和方法名一定要在同一行中，如果是不同行中，ctags就不行了，所以还是得实实在在的语法解析器出马啊！<br />　　当然，像ruby这种比较复杂的语法解析，我不需求全部自己从头开始写起，可以抄袭一部分它的代码，至少词法分析器大部分可以直接使用，而那语法解析里把BNF留下，把动作换掉， 这样虽然还是要读懂那部分代码，但总比全部自己来轻松多了，而且也可靠得多。<br />　　得稍微系统点地学习一下lex与yacc了。</p>
