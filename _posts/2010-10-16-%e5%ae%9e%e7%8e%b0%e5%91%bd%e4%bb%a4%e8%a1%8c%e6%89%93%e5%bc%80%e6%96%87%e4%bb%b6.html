---
layout: post
title: "实现命令行打开文件"
categories:
- CodingStudio
tags: []
status: publish
type: post
published: true
meta:
  quiz: a:2:{s:1:"q";s:0:"";s:1:"a";s:0:"";}
author:
  login: missdeer
  email: missdeerme@163.com
  display_name: missdeer
  first_name: "樊"
  last_name: "杨"
---
<p>　　之前我说过，作为一个文本编辑器，一个IDE，不能通过命令行参数打开一个文件，是很说不过去的。前面试图加入这个功能，结果遇到了些问题，经过昨天和今天的奋战，终于搞定了。<br />
　　其实就是发现用wxWidgets的IPC机制怎么都不能正常运行，于是最后我想到了直接用Boost的InterProcess库，这个库也是跨平台可移植的，基本处于符合我的要求的范围内。<br />
　　昨天还一直没死心，希望能用wxWidgets的IPC类搞定，结果果然无论是用DDE还是用Socket，都有问题。今天下定决心，先看了一下Boost的资料，发现其实很简单，InterProcess只是实现了共享内存的部分，再加上一点同步相关的机制，用于通知，于是只要在最老的进程中启动一个线程无限循环等待其他进程的通知，有了通知就从共享内存中读取文件路径信息，然后就可以打开了。<br />
　　顺便说一下，Boost.InterProcess的共享内存类封装得比较底层，有一个类是纯粹的对系统的C API用C++类包装了一下。另一个稍微高级一点，但也是C++语言层面的高级，感觉缺少对现实世界对象的抽象。我有点奇怪自己现在怎么会考虑到这个层面的东西，大概是因为看了一段时间的Qt的文档和代码，Qt在这方面的工作确实做得很好啊。<br />
　　还有个之前说到的，在wxApp::OnInit方法中，创建完主窗口后，直接打开文件也崩溃的问题，其实是当时测试的时候没有把配置文件放在正确的配置目录中，这个功能其实是没多少问题的。<br />
　　总之，现在就是可以通过命令行参数指定文件打开一个文件了，然后又实现了单一进程实例，后面再要通过命令行参数打开文件，都会通过IPC机制通知最早创建的那个进程来打开文件。基本完美实现预定目标！</p>
