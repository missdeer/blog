---
layout: post
title: "用boost.function和boost.bind解耦"
categories: []
tags: []
status: publish
type: post
published: true
meta:
  blogger_blog: missdeer.blogspot.com
  blogger_author: missdeerhttp://www.blogger.com/profile/18003139432457999590noreply@blogger.com
  blogger_permalink: "/2008/11/boostfuncitonboostbind.html"
author: 
---
<p>　　话说昨天被XML摆了一道，发现一种不同模块间交互的方式，就是使用回调。在早期的C语言实现中，回调函数的使用极其简单，Windows的API中就有很多使用这种方式的，可以是一个普通的全局函数，也可以是一个类的静态函数。在C++时，可调用体多了一种类成员函数，这种调用体在被调用时依赖于一个实例指针，因为编译器会自动在该函数的第一个参数前再插入一个函数，即实例指针，作为回调，就稍微麻烦一点。关于可调用体的封装和泛化，可以参考《Modern C++ Design》，中文版《C++设计新思维》。<br />　　昨天最后的结果是用boost.function，不过并没有发挥出它应有的作用，还是傻乎乎地把实例指针也传过去了，这跟直接使用原始的成员函数指针没有什么区别。后来想起来，有boost.bind的配合，可以把一个可调用体再作封装，以boost.function的形式而行为上类似于那些脚本语言的closure。在这个案例中，就是把实例指针绑定上去，这样另一个模块就根本不需要知道回调函数的原始类型了，无论是C风格的全局函数，还是类成员函数，在boost.function和boost.bind的联手作用下，都是一样的外表。这带来一个极大的好处，两个模块从此彻底解耦了。</p>
