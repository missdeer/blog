---
layout: post
title: CodeLite/Code::Blocks插件机制简单分析
categories: []
tags: []
status: publish
type: post
published: true
meta:
  quiz: s:36:"a:2:{s:1:"q";s:0:"";s:1:"a";s:0:"";}";
  _wp_old_slug: ''
author: 
---
<p>　　昨天查看了一下CodeLite和Code::Blocks的源代码，了解了一下它们的插件机制的实现情况，还是非常简单的。<br />
　　CodeLite宿主程序是一个单独的exe文件（Windows平台下），插件都是单独的dll文件。宿主程序首先声明了一组接口，这组接口定义了宿主程序可以提供给插件使用的各种服务，比如访问当前编辑器等，然后宿主程序实现这组接口。接着再声明一组接口，这组接口需要每个插件都提供自己的实现，另外，插件还需要提供几个dll标准的导出函数，用于查询插件的基本信息，比如返回版本号，返回接口创建后的实例等，这跟Windows的COM很像，只不过COM规范更完善得多。插件要实现的接口包括在菜单中添加自己的菜单项，添加工具栏等。CodeLite启动后，扫描文件夹，取出各个插件dll，查询出接口实例指针，调用插件实现的接口，并将宿主程序自己实现的服务接口指针传递给插件，这样插件就可以反过来访问宿主中的数据。<br />
　　Code::Blocks的实现跟CodeLite差别不大。Code::Blocks的宿主程序是一个很小的exe文件加一个很大的dll文件，所有的核心功能都在dll中实现，exe只是一个外壳。插件实现跟CodeLite类似，都是dll，区别在于Code::Blocks定义的插件接口类型有好几种，比如普通插件，编译套件插件，调试器插件等等，另外的区别就是，由于Code::Blocks宿主并没有采用接口的形式提供服务，而是将服务封装在核心dll中，所以插件要访问核心服务都是通过链接这个核心dll来实现的。<br />
　　从开发者的角度看，Code::Blocks需要的代码量相对小一点，因为少了宿主接口声明，以及接口实现的衔接部分。但CodeLite的接口形式提供服务封装性更好一点，更类型无关。Code::Blocks的插件开发需要核心dll的那些头文件以及链接库文件，这难免有种暴露了过多细节的嫌疑，而CodeLite则只需要接口声明就行了。所以我个人更倾向于使用CodeLite的方案。</p>
